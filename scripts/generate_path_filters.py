#!/usr/bin/env python3
"""
Generate filters.yml for dorny/paths-filter@v3 based on each project's
Polylith brick configuration in `tool.polylith.bricks`.
"""

import pathlib
import tomllib
import yaml
import sys


def read_polylith_bricks(pyproject: pathlib.Path) -> list[str]:
    """Return a list of brick names from [tool.polylith.bricks]."""
    try:
        with pyproject.open("rb") as f:
            data = tomllib.load(f)
        bricks = data.get("tool", {}).get("polylith", {}).get("bricks", [])
        return bricks
    except Exception as e:
        print(f"⚠️  Failed to parse {pyproject}: {e}", file=sys.stderr)
        return []


def generate_filters(repo_root: pathlib.Path) -> dict:
    filters = {}

    # # Shared filter — always rebuild all if core dependencies change
    # filters["shared"] = [
    #     "bases/**",
    #     "components/**",
    #     "pyproject.toml",
    #     "uv.lock",
    # ]

    projects_dir = repo_root / "projects"
    for project_dir in sorted(p for p in projects_dir.iterdir() if p.is_dir()):
        name = project_dir.name
        pyproject_path = project_dir / "pyproject.toml"
        if not pyproject_path.exists():
            print(f"⚠️  Skipping {name}: no pyproject.toml")
            continue

        bricks = read_polylith_bricks(pyproject_path)

        brick_paths = []
        for brick in bricks:
            brick_paths.append(f"{brick[6:]}/**")

        # Add the project itself (always)
        paths = [
            f"projects/{name}/**",
            *sorted(set(brick_paths)),
            f"projects/{name}/pyproject.toml",
        ]
        filters[name] = paths

    return filters


if __name__ == "__main__":
    repo_root = pathlib.Path(__file__).resolve().parents[1]
    filters = generate_filters(repo_root)

    print("# Auto-generated by scripts/generate_path_filters.py\n")
    print(yaml.dump(filters, sort_keys=False, default_flow_style=False))
